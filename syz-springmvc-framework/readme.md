#**400行代码手写实现spring MVC底层代码**

#首先回忆几个spring 面试题：

1.spring bean生命周期？
随着初始化他一直被spring容器所引用着，所以springbean的生命周期可以看做：随着spring容器的启动而出现，随着spring容器消失而消失，不过针对单例情况
2.spring bean是不是线程安全？
spring bean是否线程安全的，跟spring容器没有任何关系，spring容器只是做了存储bean，初始化等等，并没有任何线程安全操作，
而去取决于bean的应用场景，bean的里面的逻辑以及定义，在哪地方去使用，来看bean是否线程安全的。

https://www.jianshu.com/p/a56c7365e397
我们交由 Spring 管理的大多数对象其实都是一些无状态的对象，这种不会因为多线程而导致状态被破坏的对象很适合 Spring 的默认 scope，每个单例的无状态对象都是线程安全的（也可以说只要是无状态的对象，不管单例多例都是线程安全的）。
无状态的对象即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的 DO、DTO、VO 这些只作为数据的实体模型的贫血对象，还有 Service、DAO 和 Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个 DAO 提供的函数都只是对数据库的 CRUD，而且每个数据库 Connection 都作为函数的局部变量，用完即关（或交还给连接池）。
Spring 根本就没有对 bean 的多线程安全问题做出任何保证与措施。对于每个 bean 的线程安全问题，根本原因是每个 bean 自身的设计。不要在 bean 中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用 ThreadLocal 把变量变为线程私有的，如果 bean 的实例变量或类变量需要在多个线程之间共享，那么就只能使用 synchronized、lock、CAS 等这些实现线程同步的方法了。

http://www.cnblogs.com/redcool/p/6398760.html
### Spring框架中的Bean，或者说组件，获取实例的时候都是默认单例模式，这是在多线程开发的时候需要尤其注意的地方.
### 单例模式的意思是只有一个实例，例如在Spring容器中某一个类只有一个实例，而且自行实例化后并向整个系统提供这个实例，这个类称为单例类。
### 当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑（成员方法），此时就要注意了，
### 如果该处理逻辑中有对单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。　Spring框架中的Bean，或者说组件，获取实例的时候都是默认单例模式，
### 这是在多线程开发的时候需要尤其注意的地方。                                                                                                              

3.如何看源码？
最主要的核心点就是找到源码入口。本案例可以看做spring入口一种方式，其他源码也是。



#spring核心原理可看做三个阶段
#**1.配置阶段** 一般通过xml或注解    
（1）在web.xml配置spring的DispatcherServlet  他是springmvc的唯一的入口   
（2）在配置好之后，在配置spring的主配置文件application.xml  ；这个主配置文件主要是引导web容器怎么样去加载
 spring，从哪里加载。这个配置文件会去配置spring所有需要加载的东西，这里可以作为入口，也可以作为spring详细的
 配置信息。    
（3）然后还会配置url-patten,一般配置成/*或/   表示我们用一个DispatcherServlet去拦截所有的请求；在此之前我们没用spring
之前，这里配置阶段会有成千上万过servlet，每一个servlet都会配置一个url,那么会导致我们的web.xml会非常的臃肿，非常的庞大。
而带来维护的困难。有了spring mvc以后我们就可以用一个DispatcherServlet解决了所以的问题。
这就是spring在配置阶段做的一个优化。    
##配置阶段完成之后我们进入初始化阶段，而初始化是通过DispatcherServlet的中init方法开始     
#**2.spring 初始化阶段**   
**IOC**   ioc是 控制反转   他是我们编程达到的目标
（1）init方法首先会加载我们配置好的主配置文件。然后会去解析这个配置文件到底配置了什么内容。然后解析出来。   
这里一般配置都是包含了我们所有spring bean   
（2）然后会把所有的bean的实例，以及bean与对象之间的关系放入到IOC容器当中。ioc容器其实就是一个map对象而已，准确的说是list<String,Map>一个
集合包含一个map。map中用键值对的形式去存储我们配置文件中的所有的bean；   
（3）然后spring 又提供一个扫面配置；   
（4）就是把扫描的路径包下的所有类进行反射实例化，然后再把实例化的对象放入如map当中存储。    
**DI**   DI是 依赖注入  他是实现ioc的手段，di目前是最好的手段，当然还有其他方式
实例化之后进入DI注入阶段：   
DI就是把刚刚存储的对象，以及对象关系，有哪些需要赋值、有哪些需要注入的我们都在这个初始化的DI阶段完成。
所谓的DI注入，其实就是给我们这些对象的属性进行自动化的赋值。这就是DI注入。那么在DI注入赋值的时候有些值是需要我们注入的
有些是不需要我们注入的，还有必须要注入的，那么我们就可以通过注解配置，告诉spring容器，哪些是需要配置，哪些是不需要配置的。
完成这个工程之后我们就是进入了MVC阶段。   
#注：IOC和DI之间的关系：di（依赖注入）是实现ioc（控制反转）的一种手段
ioc是Martin Fowler提出的“面向对象5原则”之一。在Kent Beck提出了XP之后受其影响，Fowler将其原来空谈UML的思路，
逐步转向敏捷开发（并且主要使用了XP方法来论证敏捷开发的可行性的）思路，于是它将UML里边繁琐的OOP概念进行提炼（
就好像Beck提炼软件工程概念成为XP四条基本原则一样）而成为了OO五条原则。
因此才出现了这个第5个原则。这里不得不进行倒置，必须解决“不是正常地A调用B，而是B反过来通知A”的设计原则问题。
这里的ico只是一个基本原则，并没有讲过多具体的规定。它只是说你进行OOP程序设计时要学会使用类似事件的通知的方式，
让事件定义和触发机制的都在服务端预先定义好。此时“客户依赖于服务，而服务不依赖于客户”，因此形成了“倒置”。
（而传统的GOF四人帮所写的所谓《设计模式》中的各种模式则往往是客户和服务端相互耦合纠结才能进行通知，所以《设计模式》
中有至少一半的模式都非常臃肿和多余） 因此ioc是一种设计模式
如果你说的IOC是“面向对象5原则”你的IOC，那么你应该对照另外4个原则来看，对其意义才能明白。
**单一功能原则**，不过是说一个对象应该主题明确单一。这就跟关系库应该有一个“主键”其实是完全类似的意思。是最基本的意思。
**开闭原则和里氏替换原则**，不过是用“测试驱动”的角度来解释了对象的继承和多态的机制。
**接口隔离原则**，对滥用继承和接口做了批判，说明应该具体而准确地从业务出发来定义接口，而不能胡乱为了少写点代码来滥用借接口。
你看上述四个原则，没有一个能够涵盖“组件需要在组合在将来的工程里做为服务，被客户组建进行复用”时、其消息通知机制如何传递的问题。

ioc的好处：https://blog.csdn.net/xz0125pr/article/details/49129659

**mvc**   
mvc中有个核心的对象就是handlerMapping对象；这个对象主要就是完成了我们整个的url和Method的一对一的对应关系。通过
这个HandlerMapping保存url和Method之间关系之后。我们在前端用url去请求servlet之后，servlet会去根据这个url去找到这个
对应关系方法，然后再根据反射机制，把这个方法进行invoke（唤起/引用），然后再把这个返回值输出出来，通过浏览器在展示。
因此其实handlerMapping就是来存储这个对应关系的。    
#**3.spring 运行阶段**    
这个运行阶段就是在我们浏览器在发起一个请求开始，这个请求呢就是url.那么对应的呢就是我们后面的这个业务逻辑，这个业务逻辑
呢首先会通过handlerMapping找到这个对应的方法。那么这个方法在哪里找到的呢，应该是先进servlet，servlet里面会有一个doGet
或者DoPost方法，在这个方法里面再去调用这个HandlerMapping.去找到他，最后在去invoke.在invoke之后再通过response.writer()
方法，把结果写到浏览器返回，浏览器才能看到我们运行的结果。     
##**这个就是spring整个的运行的过程。**

#开始手写springMVC    
代码时间抽：
1.完成spring配置阶段
2.开始进行是spring初始化阶段  让上面所有的配置都起效，完成spring的初始化
（1）DispatcherServlet中的doGet/doPost首先被浏览器调用  本案例统一让他调用doPost
 